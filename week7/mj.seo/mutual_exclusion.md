# Mutual Exclusion - 상호배제
### Mutual Exclusion

- **`뮤텍스`** 또는 **`상호 배제`**는 공유 자원에 대한 **`경쟁 상태`**를 방지하고 동시성 제어를 하기위한 **락 메커니즘**이다.
- **`스레드`**가 임계영역에서 **`Mutex`** 객체의 플래그를 소유하고 있으면 **`락`**을 획득하고 다른 **`스레드`**가 **접근**할 수 없다.
- **`Mutex`** 락을 가진 오직 한개의 **`스레드`**만이 **임계영역**에 **진입**할 수 있다.
- **`락`**을 획득한 **`스레드`**만이 **락**을 **해제** 할 수 있다.

### Mutex 구현 예제

- **`Java`**에는 **`Mutex`**를 명시적으로 **클래스**로 **제공**하지 않는다.

```java
public class Mutex {

    private boolean lock = false;

    // 하나의 스레드만 접근할 수 있도록 synchronized 메서드로 선언
    public synchronized void acquired() {
        while (lock) {
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        this.lock = true;
    }

    public synchronized void release() {
        this.lock = false;
        // 대기 중인 스레드를 깨운다.
        this.notify();
    }
}
```

### Mutex의 문제점

- **`Deadlock`**
    - 잘못된 **`뮤텍스`** 사용으로 인해서 **`데드락`**이 발생할 수 있다.
    - 원인 → 서로가 가진 **`락`**을 기다리면서 **`상호적`**으로 **블로킹**되어 아무 작업도 수행할 수 없음

- **`우선 순위 역전`**
    - **높은 우선순위**를 가진 스레드가 **낮은 우선순위**를 가진 스레드가 `보유한 락`을 기다리는 동안 **블록**되는 현상이다.
    - **`우선 순위 상속`**으로 **해결**할 수 있다.

- **`오버헤드`**
    - **`뮤텍스`**를 사용하면 여러 스레드가 **`경합`**하면서 락을 얻기 위해 **`스레드 스케줄링`**이 발생한다.

- **`성능 저하`**
    - 여러 스레드가 **`락`**을 놓고 **경합**하는 과정에서 **`스레드`**가 **`대기`**하게 되고 스레드의 **`실행 시간`**이 **블록**되면서 **성능 저하**가 **발생**한다.

- **`잘못된 사용`**
    - **`뮤텍스`**를 적절하지 사용하지 않거나 잘못된 순서로 **`락`**을 **`해제`**하면 예기치 않은 동작이 발생할 수 있다.
