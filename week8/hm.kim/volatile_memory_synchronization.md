개요

---

변수의 가시성과 연산의 순서를 제어하기 위해 사용하는 키웓, 쓰레드 간 데이터 일관성 및 가시성 보장

---

### CPU 캐시 메모리와 메인 메모리

---

- 현대 컴퓨터는 2개 이상의 CPU 장착, 각 코어에는 레지스터와 캐시 메모리가 존재한다.
- CPU 캐시 메모리는 CPU 레지스터와 메인 메모리 사이에서 데이터 흐름을 최적화 및 성능 향상을 위해 사용되는 고속 메모리이다.
- CPU는 값을 읽어올 때 우선, 캐시에 해당하는 값이 있는지 확인하고 없는 경우 메인메모리에서 읽어오는 특성을 가진다.

---

### CPU가 데이터 처리를 위해 메인 메모리로 접근하는 순서

---

1. CPU는 메인 메모리의 데이터를 CPU 캐시로 읽어들인다.
2. 캐시 데이터를 CPU 레지스터로 다시 읽어들이고, 읽어온 데이터로 명령을 수행한다.
3. 데이터를 다시 메인 메모리에 저장하기 위해서는 데이터를 읽어들일 때 과정을 역순으로 진행한다.
4. 작업 결과를 레지스터에서 캐시로 보내고, 적절한 시점에 캐시에서 메인메모리로 보낸다.

---

### 가시성 (visibility)

---

- 멀티쓰레드 환경에서 공유 변수의 변경 내용이 쓰레드에서 다른 쓰레드에게 어떻게 보이는지의 개념
- 멀티쓰레드환경에서는 동시에 엑세스/수정 할 수 있기에 모든 쓰레드에게 가시성이 확보되어야 한다.

---

### 가시성 문제

---

- CPU 캐시에서 작업한 결과가 메인 메모리에 즉시 반영되지 않을 경우, 쓰레드 간 결과가 다른 현상

---

1. CPU1 은 메인 메모리로부터 값을 읽어와 1을 더한 값을 캐시에 저장하고, 메인 메모리에 반영X
2. T2는 CPU에서 변경한 데이터가 메인 메모리에 반영되지 않은 상태에서 값을 읽기에 두 쓰레드는
   서로 다른 캐시 값을 바라보는 가시성 문제가 발생한다.
3. 쓰레드 간 가시성을 확보하기 위해서는 CPU가 작업한 결과를 즉시 메인 메모리에 반영해야 하며
   쓰레드는 캐시가 아닌 메인 메모리에서 값을 참조해야 한다.

### volatile 원리

---

- 캐시 메모리 현상, 공유 변수에 대해 쓰레드 간 가시성 문제가 발생할 경우, volatile 키워드 사용
- 공유변수에 volatile 키워드 선언 시 CPU가 데이터 작업 할 때 메인 메모리에서 공유변수를 직접
  읽고 수정된 결과를 메모리에 즉시적으로 반영하여 가시성 문제를 해결한다.

---

### 경쟁 조건 (Race Condition)

---

쓰레드 간 경쟁조건을 벌여 CPU의 캐시 메모리에 비정상
데이터 저장되고 잘못된 결과가 메인 메모리에 업데이트 되는 현상

---

1. CPU1, CPU2가 동시에 메모리에서 sharedData 값을 읽어와 1을 더한 값을 캐시에 저장한다.
2. CPU1, CPU2에 할당된 쓰레드들은 경쟁조건으로 인해 두 캐시에 똑같은 2의 값을 저장한다.
3. 캐시 값을 메인 메모리에 반영해도, 캐시 자체가 이미 잘못된 값을 가졌기에 프로그램은 비정상 동작

---

### synchronized

---

- 한 시점에 오직 하나의 쓰레드가 동기화 영역에 접근할 수 있도록 보장해준다.
- 참조되는 모든 변수들은 메인 메모리로부터 읽어들여지고
  블록을 벗어나면 수정 변수들이 즉시 메인 메모리로 반영될 수 있도록 해준다.
- 상호배제와 함께 가시성의 문제까지 해결할 수 있는 기능을 포함하고 있다.

---

### volatile 한계점

---

- volatile은 쓰레드 간 공유변수에 대한 가시성을 보장하지만, 동시적 상호배제를 보장해주지 않는다.
- volatile 변수를 읽기작업하는 쓰레드와 쓰기작업하는 쓰레드가 N:1 상황에서는
  동시성을 보장하지만, N:N의 상황에서는 동시성을 보장하지 못한다. (synchronized를 써야한다)

---

### Happens - Before 보장

---

- volatile 변수를 사용하면 해당 변수를 읽기/쓰기 작업이 특별한 규칙에 따라 재정렬되지 않도록 보장
- volatile 변수 전과 후에 실행되는 명령은 JVM 컴파일러에 의해 재정렬 될 수
  있으나 volatile 변수에 대한 명령 이전 / 이후에 존재한다는 규칙은 반드시 지켜진다.