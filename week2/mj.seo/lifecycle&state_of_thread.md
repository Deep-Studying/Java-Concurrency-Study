# 스레드 생명주기와 상태

### Java Thread 상태

- `JVM`에서는 **6가지 Thread 상태**가 존재한다.
- `OS Thread` 상태를 의미하지 않으며, **서로 일치하지 않을 수 있다.**
- 현재 `Thread`의 상태는 `getState()` 메서드로 가져올 수 있다.

- **NEW - 객체 생성**
    - Thread 객체가 `생성됨`
- **RUNNABLE - 실행 대기 or 실행 중**
    - `실행 중`이거나 `실행 가능`한 스레드 상태
- **WAITING - 실행 대기**
    - `대기 중`인 스레드 상태로서 다른 스레드가 특정 작업을 수행하기를 기다림
- **TIMED_WAITING - 일시 정지**
    - `대기 시간`이 지정된 스레드 상태로서 **다른 스레드가 특정 작업을 수행**하기를 기다림
- **BLOCKED - 일시 정지**
    - `모니터 Lock`이 해제될 때 까지 기다리며 차단된 스레드 상태
- **TERMINATED - 종료**
    - **실행이 완료**된 스레드 상태

### Thread 생명주기

- **객체 생성 상태**
    - `Thread` 객체는 생성되었으나 `start()` 하지 않은 상태다.
    - `커널`로의 실행은 안 된 상태라고 보면된다.

- **실행 대기 상태**
    - `start()`를 실행하면 내부적으로 `커널`로의 `실행`이 일어난다.
    - `start()`를 호출한다고 해서, 스레드는 바로 실행되지 않고 언제든지 실행 가능한 상태가 된다.
    - `스레드`가 실행상태로 전환하려면 반드시 **실행 대기 상태**를 거쳐야한다.

- **실행 상태**
    - `스레드`는 OS 스케줄러에 의해 스케줄링 되면 `CPU`를 할당받고 `run()` 메서드를 실행한다.
    - **실행 상태**에서 **생성**과 **종료** 상태를 제외한 다른 상태로 전환될 때 `컨텍스트 스위칭`이 일어난다.

- **실행 상태 → 실행 대기 상태**
    - 실행 상태에서 `yield()` 메서드를 호출하거나 운영체제 스케줄러에 의해 **CPU 실행을 일시 중지**하면 `실행대기 상태`로 전환된다.

- **일시 정지 상태 (지정된 시간이 있을 때)**
    - 스레드는 `sleep` 및 `time-out` 매개변수가 있는 메서드를 호출하면 지정된 시간 만큼 **대기 상태**가 된다.
    - `대기 시간`의 한계가 있기 때문에 **CPU**의 할당을 지속적으로 받지 못하는 `기아 상태`를 피할 수 있다.

- **실행 대기 상태**
    - `스레드`의 일시 정지 상태가 해소되거나 `다른 스레드`에 의해 **인터럽트**가 발생하는 경우, **대기를 해제하라는 통지**를 받으면 실행 대기 상태가 된다.

- **일시 정지 상태 (차단)**
    - `스레드`가 동기화 된 임계 영역 접근을 시도하다가 `Lock`을 획득하지 못한 상태
    - `Lock`을 획득할 때 까지 대기한다.

- **일시 정지 상태 → 실행 대기 상태**
    - `스레드`가 `Lock`을 획득하게 되면 실행 대기 상태가 된다.

- **일시 정지 상태**
    - `스레드`가 실행 상태에서 `다른 스레드`의 작업 수행을 기다리는 상태
    - `wait()`은 다른 스레드에 의해 `notify()`를 받을 때까지 대기한다.
    - `join()`은 스레드의 실행이 종료되거나 **인터럽트가 발생**할 때까지 대기한다.

- **일시 정지 상태 → 실행 대기 상태**
    - 다른 스레드에 의해 `notify()` & `notifyAll()` 이 일어나면 대기중인 스레드가 **실행 대기 상태**가 된다.
    - `다른 스레드`에 의해 인터럽트가 발생해도 **실행 대기 상태**로 **전환**한다.

- **실행 종료 상태**
    - `실행`이 `완료`되거나 **예외 & 에러** 등으로 비정상적으로 종료된 상태
    - 한 번 종료된 스레드는 **다시 사용할 수 없다.**
