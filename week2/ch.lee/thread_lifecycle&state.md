# 스레드 실행 및 종료
- **JVM에서 자바 스레드는 6가지 상태가 존재(OS 스레드 상태 X)**
- **어떤 시점에든 오직 1개의 상태, getState()을 통해 가져올 수 있다.**

```java
객체 생성 : NEW 
→ 스레드 객체 생성, 아직 시작 X

실행 대기 : RUNNABLE
→ 실행 중,실행 가능한 스레드 상태

일시 정지 : WAITING
→ 다른 스레드가 특정 작업을 수행하기 위해 기다리는 상태

일시 정지 : TIMED_WAITING
→ 대기시간이 지정됨, 다른 스레드가 특정 작업을 수행하기 위해 기다리는 상태

일시 정지 : BLOCKED
→ 모니터 락이 해제될 때까지 기다리며 차단된 상태

종료 : TERMINATED
→ 실행이 완료된 상태
```
---

실행 대기 상태
- start()을 실행하면, 내부적으로 커널로의 실행으로 커널 스레드와 1:1 매핑 진행
- 스레드는 바로 실행 상태가 아닌 **언제든지 실행 가능한 상태**가 된다.
- 실행상태로의 전환은 현재 스레드가 어떤 상태로 존재하든지 **반드시 실행 대기 상태**를 거친다.

스케줄링
- 실행한 가능한 상태의 스레드에게 실행할 시간을 제공하는 것은 **OS 스케줄러 책임**
- 멀티스레드 환경에서 각 스레드에게 고정된 시간을 할당해서 실행 상태와 실행 가능한 상태를 오가도록 스케줄링 진행

실행 상태
- 스케줄링되면 실행 상태로 전환되고 CPU를 할당받아 run() 실행
- 아주 짧은 시간동안 실행된 다음 다른 스레드가 실행될 수 있도록 CPU를 일시 중지하고 다른 스레드에 양도
- 실행 상태에서 생성과 종료 상태를 제외한 다른 상태로 전환될 때 스레드 혹은 프로세스 간 컨텍스트 스위칭 발생

실행 상태 → 실행 대기 상태
- 실행 상태에서 스레드의 yield() 메서드 호출 및 OS 스케줄러에 의해 CPU 실행을 일시 중지한 경우 실행 가능한 상태로 전환

→ 일시 정지 상태(지정된 시간이 있는 경우)
```java
sleep(time), wait(time), join(timout)
```
- 스레드는 sleep 및 time-out 매개변수가 있는 메서드를 호출할 때 시간이 지정된 대기 상태가 된다.
- 대기 시간이 길어지고, CPU 할당을 계속 받지 못하는 상황이 발생하면 기아 상태가 발생되는데 이 상황을 피할 수 있다.

실행 대기 상태
- 대기 상태의 지정시간이 완료되거나 다른 스레드에 의해 인터럽트가 발생하거나 대기가 해제되면 실행 대기 상태가 된다.

임계 영역 동시적 접근
- 멀티 스레드 환경에서 각 스레드가 동기화 된 임계 영역을 접근 시도

일시 정지 상태(차단됨)
- 스레드가 동기화된 임계 영역에 접근 시도하다가 Lock을 획득하지 못해서 차단된 상태
- 스레드는 Lock을 획득할 때까지 대기한다.
- 스레드가 Lock을 획득하면 실행 대기 상태로 변경된다.

일시 정지 상태
- 스레드가 실행 상태에서 다른 스레드가 특정 작업을 수행하기 위해 기다리는 상태
- wait()은 다른 스레드에 의해 notify()을 받을 때까지, join()은 스레드의 실행이 종료되거나 인터럽트가 발생할 때까지 대기한다.
---
### 스레드를 잘 운용하기 위해서는 스레드 생명주기와 상태를 잘 알아야 한다.
- 스레드는 어떤 상황, 시점, 조건에 의해 상태 전이가 일어났는가?
- 스레드 API를 사용함에 있어, 해당 API가 어떤 상태를 일으키며 스레드간 영향을 미치게 되는가?
- 스레드 실행 관점에서는 출발지가 start()메소드 실행이라면 목적지는 run() 메소드 실행이 된다는 점