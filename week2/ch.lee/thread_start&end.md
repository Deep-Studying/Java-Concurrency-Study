# 스레드 실행 및 종료

- **Java Thread는 OS 스케줄러에 의해 실행 순서가 결정**

-> **스레드 실행 시점은 JVM에서 제어 X, Kernel Thread와 1:1매핑이기 때문!**

- **새로운 스레드는 현재 스레드와 독립적으로 실행됩니다.**
- **최대 1번 시작하고 스레드 종료시 다시 시작 X**

---
## 스레드 실행(start())
1. **메인 스레드가 새로운 스레드를 생성한다**
2. **메인 스레드가 start() 메서드를 호출해서 스레드를 실행을 시작한다.**
3. **내부적으로 네이티브 메서드 start()를 호출해 커널에게 커널스레드 생성하도록 시스템 콜을 요청한다.**
4. **커널 스레드가 생성되고 자바스레드와 커널스레드가 1:1 매핑이 이루어진다.**
5. **커널 스레드는 OS 스케줄러로부터 CPU 할당을 받기까지 실행대기 상태에 있다.**
6. **커널 스레드가 스케줄러에 의해 실행상태가 되면 JVM에서 매핑된 자바 스레드의 run() 호출을 진행한다.**

---
## 스레드 실행(run())
**스레드 호출시 자동 호출**

**Runnable 구현체 존재 시 Runnable의 run() 실행**

→ static void main(String[] args)와 유사

```java
주의

start() X → run() : 메서드를 직접 호출하면 실행스택에서 run()이 실행
  → 다른 스레드에서 실행되지 않는다
```
---
## 스레드 스택
**- 스레드가 생성 → 스레드를 위한 스택이 만들어진다.**

**- 각 스택은 스레드마다 독립적으로 할당되어 동작 → 스레드간 접근 및 공유 X → 스레드 안전!**

**- 스택은 OS에 따라 크기가 주어지며, 주어진 크기가 넘으면 StackOverFlowError가 발생**

### 스택 메모리 상태 관리
- **스택 내부의 변수는 변수를 생성한 메서드가 실행되는 동안 존재**
- **스택 메모리에 대한 액세스는 Heap 메로리와 비교할 때 빠르다**

**→ 근접한 스택 메모리에서 액세스를 진행하기 때문**

- **지역 변수는 Stack Frame 안에서 가지고 있는 것을 확인할 수 있다.**
- **문자열이나 객체에 같은 경우에는 Heap 메모리에 존재하는 데이터를 참조합니다.**

**→ String은 객체와 다른 String pool에서 관리한다.**

---
## 스레드 종료
- **스레드는 run() 메서드 코드가 모두 실행되면 종료**
- **스레드는 예외 발생시 종료되고, 다른 스레드에 영향 X**
- **어플리케이션은 싱글스레드인 경우 멀티 스레드인 경우 종료 기준이 다르다.**

```java
싱글 스레드 : application 종료 
→ thread 종료(main thread 1개 이기 때문)

멀티 스레드 : JVM에서 실행되는 모든 스레드가 종료되어야 어플리케이션이 종료
→ 동일한 코드 실행되는 각 스레드의 종료 시점은 처리시간 및 OS 스케줄링에 따라 결정되어 매번 다를 수 있다.
```
